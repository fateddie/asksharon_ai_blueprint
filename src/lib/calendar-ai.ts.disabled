import OpenAI from 'openai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export interface CalendarEvent {
  id?: string
  title: string
  start: string
  end: string
  description?: string
  location?: string
  attendees?: Array<{
    email: string
    name?: string
  }>
}

export interface SchedulingSuggestion {
  suggestedTime: string
  duration: number
  title: string
  reasoning: string
  confidence: number
  conflictFree: boolean
  optimalTimeScore: number
}

export interface CalendarInsights {
  busyHours: Array<{ hour: number, meetingCount: number }>
  freeTimes: Array<{ start: string, end: string }>
  meetingPatterns: {
    averageDuration: number
    mostCommonHours: number[]
    dailyMeetingCount: number
    weeklyTrends: Array<{ day: string, count: number }>
  }
  suggestions: {
    bestTimeForFocus: string[]
    recommendedMeetingTimes: string[]
    workLifeBalance: {
      score: number
      suggestion: string
    }
  }
}

export class CalendarAI {
  async analyzeCalendarPatterns(events: CalendarEvent[]): Promise<CalendarInsights> {
    const now = new Date()
    const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000)

    // Filter recent events for pattern analysis
    const recentEvents = events.filter(event => {
      const eventDate = new Date(event.start)
      return eventDate >= now && eventDate <= nextWeek
    })

    // Analyze busy hours
    const busyHours = this.analyzeBusyHours(recentEvents)

    // Find free times
    const freeTimes = this.findFreeTimes(recentEvents)

    // Calculate meeting patterns
    const meetingPatterns = this.calculateMeetingPatterns(recentEvents)

    // Generate AI-powered suggestions
    const suggestions = await this.generateSmartSuggestions(recentEvents, busyHours)

    return {
      busyHours,
      freeTimes,
      meetingPatterns,
      suggestions
    }
  }

  private analyzeBusyHours(events: CalendarEvent[]): Array<{ hour: number, meetingCount: number }> {
    const hourCounts: { [hour: number]: number } = {}

    events.forEach(event => {
      const startHour = new Date(event.start).getHours()
      const endHour = new Date(event.end).getHours()

      for (let hour = startHour; hour <= endHour; hour++) {
        hourCounts[hour] = (hourCounts[hour] || 0) + 1
      }
    })

    return Object.entries(hourCounts)
      .map(([hour, count]) => ({ hour: parseInt(hour), meetingCount: count }))
      .sort((a, b) => b.meetingCount - a.meetingCount)
  }

  private findFreeTimes(events: CalendarEvent[]): Array<{ start: string, end: string }> {
    const workStart = 9 // 9 AM
    const workEnd = 18 // 6 PM
    const freeTimes: Array<{ start: string, end: string }> = []

    const today = new Date()
    today.setHours(workStart, 0, 0, 0)

    for (let day = 0; day < 7; day++) {
      const currentDay = new Date(today.getTime() + day * 24 * 60 * 60 * 1000)
      const dayEvents = events.filter(event => {
        const eventDate = new Date(event.start)
        return eventDate.toDateString() === currentDay.toDateString()
      }).sort((a, b) => new Date(a.start).getTime() - new Date(b.start).getTime())

      let currentTime = new Date(currentDay)

      dayEvents.forEach(event => {
        const eventStart = new Date(event.start)

        if (eventStart.getTime() - currentTime.getTime() >= 60 * 60 * 1000) { // 1 hour gap
          freeTimes.push({
            start: currentTime.toISOString(),
            end: eventStart.toISOString()
          })
        }

        currentTime = new Date(event.end)
      })

      // Add remaining time until end of work day
      const endOfDay = new Date(currentDay)
      endOfDay.setHours(workEnd, 0, 0, 0)

      if (endOfDay.getTime() - currentTime.getTime() >= 60 * 60 * 1000) {
        freeTimes.push({
          start: currentTime.toISOString(),
          end: endOfDay.toISOString()
        })
      }
    }

    return freeTimes.slice(0, 10) // Top 10 free slots
  }

  private calculateMeetingPatterns(events: CalendarEvent[]): CalendarInsights['meetingPatterns'] {
    const durations = events.map(event => {
      const start = new Date(event.start)
      const end = new Date(event.end)
      return (end.getTime() - start.getTime()) / (1000 * 60) // minutes
    })

    const hours = events.map(event => new Date(event.start).getHours())
    const dailyCounts: { [day: string]: number } = {}

    events.forEach(event => {
      const day = new Date(event.start).toLocaleDateString('en-US', { weekday: 'long' })
      dailyCounts[day] = (dailyCounts[day] || 0) + 1
    })

    return {
      averageDuration: durations.length > 0 ? durations.reduce((a, b) => a + b, 0) / durations.length : 0,
      mostCommonHours: this.getMostFrequent(hours, 3),
      dailyMeetingCount: events.length / 7,
      weeklyTrends: Object.entries(dailyCounts).map(([day, count]) => ({ day, count }))
    }
  }

  private getMostFrequent(arr: number[], count: number): number[] {
    const frequency: { [key: number]: number } = {}
    arr.forEach(item => frequency[item] = (frequency[item] || 0) + 1)

    return Object.entries(frequency)
      .sort(([,a], [,b]) => b - a)
      .slice(0, count)
      .map(([hour]) => parseInt(hour))
  }

  private async generateSmartSuggestions(
    events: CalendarEvent[],
    busyHours: Array<{ hour: number, meetingCount: number }>
  ): Promise<CalendarInsights['suggestions']> {
    try {
      const prompt = `
Analyze this calendar data and provide productivity suggestions:

Recent Events: ${events.length} meetings scheduled
Busy Hours: ${busyHours.slice(0, 5).map(h => `${h.hour}:00 (${h.meetingCount} meetings)`).join(', ')}

Calendar Context:
- Average events per day: ${(events.length / 7).toFixed(1)}
- Peak meeting hours: ${busyHours.slice(0, 3).map(h => h.hour).join(', ')}

Provide suggestions in JSON format:
{
  "bestTimeForFocus": ["array of 3 suggested focus time blocks (e.g., '9:00-11:00 AM')"],
  "recommendedMeetingTimes": ["array of 3 optimal meeting time slots"],
  "workLifeBalance": {
    "score": 0-100,
    "suggestion": "specific recommendation for better balance"
  }
}

Consider:
- Avoiding back-to-back meetings
- Protecting deep work time
- Optimal energy levels throughout the day
- Work-life boundaries
`

      const response = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'You are a productivity expert analyzing calendar patterns. Provide actionable scheduling suggestions based on meeting data. Always respond with valid JSON.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 400
      })

      const result = response.choices[0]?.message?.content
      if (!result) throw new Error('No response from OpenAI')

      return JSON.parse(result)
    } catch (error) {
      console.error('Error generating calendar suggestions:', error)
      return {
        bestTimeForFocus: ['9:00-11:00 AM', '2:00-4:00 PM', '7:00-9:00 PM'],
        recommendedMeetingTimes: ['10:00 AM', '2:00 PM', '4:00 PM'],
        workLifeBalance: {
          score: 75,
          suggestion: 'Consider blocking focus time and limiting meetings after 5 PM'
        }
      }
    }
  }

  async suggestOptimalMeetingTime(
    title: string,
    duration: number,
    existingEvents: CalendarEvent[],
    attendeeEmails: string[] = []
  ): Promise<SchedulingSuggestion[]> {
    try {
      const freeTimes = this.findFreeTimes(existingEvents)
      const suggestions: SchedulingSuggestion[] = []

      // Generate suggestions for next 5 business days
      for (const freeSlot of freeTimes.slice(0, 10)) {
        const start = new Date(freeSlot.start)
        const end = new Date(start.getTime() + duration * 60 * 1000)

        if (end <= new Date(freeSlot.end)) {
          const conflictFree = !this.hasConflict(start, end, existingEvents)
          const optimalTimeScore = this.calculateOptimalTimeScore(start)

          suggestions.push({
            suggestedTime: start.toISOString(),
            duration,
            title,
            reasoning: `Available ${duration}-minute slot with optimal time score of ${optimalTimeScore}`,
            confidence: conflictFree ? 0.9 : 0.6,
            conflictFree,
            optimalTimeScore
          })
        }
      }

      return suggestions
        .sort((a, b) => b.optimalTimeScore - a.optimalTimeScore)
        .slice(0, 5)
    } catch (error) {
      console.error('Error suggesting meeting times:', error)
      return []
    }
  }

  private hasConflict(start: Date, end: Date, events: CalendarEvent[]): boolean {
    return events.some(event => {
      const eventStart = new Date(event.start)
      const eventEnd = new Date(event.end)
      return (start < eventEnd && end > eventStart)
    })
  }

  private calculateOptimalTimeScore(time: Date): number {
    const hour = time.getHours()
    const day = time.getDay()

    let score = 50 // Base score

    // Prefer business hours
    if (hour >= 9 && hour <= 17) score += 30

    // Prefer mid-morning and mid-afternoon
    if (hour >= 10 && hour <= 11) score += 20
    if (hour >= 14 && hour <= 16) score += 15

    // Avoid lunch time
    if (hour >= 12 && hour <= 13) score -= 15

    // Prefer weekdays
    if (day >= 1 && day <= 5) score += 20

    // Prefer Tuesday-Thursday
    if (day >= 2 && day <= 4) score += 10

    return Math.min(100, Math.max(0, score))
  }
}

export const calendarAI = new CalendarAI()