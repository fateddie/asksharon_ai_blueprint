import OpenAI from 'openai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export interface EmailCategory {
  category: 'urgent' | 'important' | 'work' | 'personal' | 'promotional' | 'newsletter' | 'spam'
  priority: 'high' | 'medium' | 'low'
  action: 'respond' | 'review' | 'archive' | 'delete' | 'schedule_reply'
  confidence: number
  reasoning: string
  suggestedResponse?: string
}

export interface EmailInsight {
  subject: string
  from: string
  snippet: string
  category: EmailCategory
  extractedInfo: {
    deadlines?: string[]
    actionItems?: string[]
    meetingRequests?: {
      proposedTimes: string[]
      location?: string
    }
    keyContacts?: string[]
  }
}

export class EmailAI {
  async categorizeEmail(email: {
    subject: string
    from: string
    snippet: string
    body?: string
  }): Promise<EmailCategory> {
    try {
      const prompt = `
Analyze this email and categorize it:

Subject: ${email.subject}
From: ${email.from}
Content: ${email.snippet}

Please categorize this email and provide a JSON response with:
{
  "category": "urgent|important|work|personal|promotional|newsletter|spam",
  "priority": "high|medium|low",
  "action": "respond|review|archive|delete|schedule_reply",
  "confidence": 0.0-1.0,
  "reasoning": "brief explanation",
  "suggestedResponse": "optional suggested reply if action is respond"
}

Consider:
- Urgency indicators (deadlines, "urgent", "ASAP", "today")
- Sender importance (boss, client, automated systems)
- Content type (meeting requests, newsletters, promotions)
- Action required (questions, requests, FYI)
`

      const response = await Promise.race([
        openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: 'You are an expert email assistant. Analyze emails and provide structured categorization to help with productivity. Always respond with valid JSON.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.3,
          max_tokens: 500
        }),
        new Promise((_, reject) => setTimeout(() => reject(new Error('OpenAI timeout')), 10000))
      ])

      const result = response.choices[0]?.message?.content
      if (!result) throw new Error('No response from OpenAI')

      return JSON.parse(result) as EmailCategory
    } catch (error) {
      console.error('Error categorizing email:', error)
      // Fallback categorization
      return {
        category: 'work',
        priority: 'medium',
        action: 'review',
        confidence: 0.5,
        reasoning: 'Fallback categorization due to AI service error'
      }
    }
  }

  async extractEmailInsights(emails: Array<{
    subject: string
    from: string
    snippet: string
  }>): Promise<EmailInsight[]> {
    const insights: EmailInsight[] = []

    // Process emails in batches to avoid rate limits
    for (const email of emails.slice(0, 10)) {
      try {
        const category = await this.categorizeEmail(email)
        const extractedInfo = await this.extractActionItems(email)

        insights.push({
          ...email,
          category,
          extractedInfo
        })
      } catch (error) {
        console.error(`Error processing email: ${email.subject}`, error)
      }
    }

    return insights
  }

  private async extractActionItems(email: {
    subject: string
    snippet: string
  }): Promise<EmailInsight['extractedInfo']> {
    try {
      const prompt = `
Extract actionable information from this email:

Subject: ${email.subject}
Content: ${email.snippet}

Extract and return JSON with:
{
  "deadlines": ["list of any dates/deadlines mentioned"],
  "actionItems": ["list of tasks or actions requested"],
  "meetingRequests": {
    "proposedTimes": ["any suggested meeting times"],
    "location": "meeting location if mentioned"
  },
  "keyContacts": ["important people mentioned by name"]
}

Only include items that are explicitly mentioned. Return empty arrays if nothing found.
`

      const response = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'Extract specific actionable information from emails. Be precise and only include explicitly mentioned items. Always respond with valid JSON.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 300
      })

      const result = response.choices[0]?.message?.content
      if (!result) return {}

      return JSON.parse(result)
    } catch (error) {
      console.error('Error extracting action items:', error)
      return {}
    }
  }

  async generateEmailSummary(emails: EmailInsight[]): Promise<{
    urgentCount: number
    actionRequired: number
    totalProcessed: number
    keyHighlights: string[]
    suggestedActions: Array<{
      action: string
      email: string
      priority: string
    }>
  }> {
    const urgentEmails = emails.filter(e => e.category.priority === 'high')
    const actionEmails = emails.filter(e =>
      e.category.action === 'respond' || e.category.action === 'schedule_reply'
    )

    const keyHighlights: string[] = []
    const suggestedActions: Array<{action: string, email: string, priority: string}> = []

    // Generate highlights
    urgentEmails.forEach(email => {
      keyHighlights.push(`Urgent: ${email.subject} from ${email.from}`)
    })

    // Generate suggested actions
    actionEmails.slice(0, 5).forEach(email => {
      suggestedActions.push({
        action: email.category.action === 'respond' ? 'Reply required' : 'Schedule reply',
        email: `${email.subject} (${email.from})`,
        priority: email.category.priority
      })
    })

    return {
      urgentCount: urgentEmails.length,
      actionRequired: actionEmails.length,
      totalProcessed: emails.length,
      keyHighlights: keyHighlights.slice(0, 5),
      suggestedActions
    }
  }
}

export const emailAI = new EmailAI()